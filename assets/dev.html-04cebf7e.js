import{_ as n,M as o,p as i,q as r,R as t,t as e,N as d,a1 as a}from"./framework-5866ffd3.js";const h={},c=a('<h1 id="developement" tabindex="-1"><a class="header-anchor" href="#developement" aria-hidden="true">#</a> Developement</h1><p>In this section you will find (I hope) everything you need to understand how the project works and how to contribute.</p><h2 id="general-architecture" tabindex="-1"><a class="header-anchor" href="#general-architecture" aria-hidden="true">#</a> General Architecture</h2><p>There are 3 folders:</p><ul><li>server: Responssible for data storage (grids, dictionnary, options) and search</li><li>client: Responssible for user input, UI</li><li>grid: Code for common things between client and server, holds types and some helper classes.</li></ul><h2 id="server" tabindex="-1"><a class="header-anchor" href="#server" aria-hidden="true">#</a> Server</h2><p>The server is an <code>express</code> app with a few tests, it could use some more validation on <code>CRUD</code> requests.</p><h3 id="database" tabindex="-1"><a class="header-anchor" href="#database" aria-hidden="true">#</a> Database</h3><p>I used the simplest database I could: <code>JSON</code> files. Because there will never be much data, there is no need for any external tool and it is humand readable. It is stored within the paths defined in the <code>.env</code> files:</p><ul><li><code>APP_CROSSWORDS_GRIDS_PATH</code>: path for the grids.json</li><li><code>APP_CROSSWORDS_OPTIONS_PATH</code>: path for the options.json</li><li><code>APP_CROSSWORDS_DICO_PATH</code>: Folder for static dictionnary (user cannot modify it from client)</li><li><code>APP_CROSSWORDS_WORDS_PATH</code>: path for the csv file containing user&#39;s custom words(dumpe there with comma to separate them)</li></ul><p>Everytime we make a database operation (create/update/delete), it writes immediatally the changes in the <code>.json</code> files. So when user makes a request to the server, the result is saved before sending the response.</p><h3 id="search" tabindex="-1"><a class="header-anchor" href="#search" aria-hidden="true">#</a> Search</h3>',12),l={href:"https://github.com/Leo-Nicolle/mots-fleches/wiki/Automatic-generation",target:"_blank",rel:"noopener noreferrer"},p=a(`<h3 id="optionscontroller" tabindex="-1"><a class="header-anchor" href="#optionscontroller" aria-hidden="true">#</a> OptionsController</h3><p>I think I&#39;ll rename it <code>Styles</code> later. I added some new keys to export the solutions, but they are stored within the same file. We&#39;ll have new entity soon : <code>Book</code> which holds a list of grids, an Option and a SolutionOption. For now the Grids holds an <code>Option</code> id but it is ignored in the client for export, so it is useless.</p><h2 id="client" tabindex="-1"><a class="header-anchor" href="#client" aria-hidden="true">#</a> Client</h2><p>The client is a <code>Vue</code> app, written with <code>composition</code> API and <code>setup</code> files. It does not have a global state, as it is simple enough for now.</p><h3 id="views" tabindex="-1"><a class="header-anchor" href="#views" aria-hidden="true">#</a> Views</h3><p>There are three main types of view:</p><ul><li>The views for printing: they just display <code>Page</code> components with the things to print.</li><li>The views to edit: they have a <code>-Editor</code>, they send post requests to the server, updating the edited entity.</li><li>The views to create/delete: They show all entities in a Grid Layout with a preview.</li></ul><h3 id="forms" tabindex="-1"><a class="header-anchor" href="#forms" aria-hidden="true">#</a> Forms</h3><p>Usually all the forms are displayed in the left panel, they use <code>v-model</code> and send a <code>@update</code> event. The component holding them either resends the <code>@update</code> event, either send a <code>post</code> request to the server</p><h3 id="renderer" tabindex="-1"><a class="header-anchor" href="#renderer" aria-hidden="true">#</a> Renderer</h3><p>The core of the whole app ! It renders a Grid into SVG. Pretty straightforward, for the future I might add:</p><ul><li>simplification of the SVG by using <code>styles</code> and <code>classes</code> for colors, stroke sizes, fonts etc. It is just not handy with Vue to do that ( when you want to download it and render it into other software)</li><li>Font embedding ? In the case of downloading the SVG, it would be nice to embed the fonts as data64</li></ul><p>The <code>GridInput</code> component is used to type stuff within the grid. It is just a <code>textarea</code> placed on top of the SVG. It is not perfect as I had to take in account the scroll. Maybe add a slot within <code>Grid</code> and then use relative placement ?</p><h3 id="paper-components" tabindex="-1"><a class="header-anchor" href="#paper-components" aria-hidden="true">#</a> Paper components</h3><p>Thoose are used to render entities for printing. Not sure we really need it as we already have the <code>views</code>.</p><h2 id="testing" tabindex="-1"><a class="header-anchor" href="#testing" aria-hidden="true">#</a> Testing</h2><h3 id="server-1" tabindex="-1"><a class="header-anchor" href="#server-1" aria-hidden="true">#</a> server</h3><p>Just run</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> <span class="token builtin class-name">test</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Tests use <code>vitest</code> and the <code>setup</code> file to overrite the paths. We could use more tests on search.</p><h3 id="client-1" tabindex="-1"><a class="header-anchor" href="#client-1" aria-hidden="true">#</a> client</h3><p>You need to start the server in test mode:</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> server
<span class="token function">npm</span> run e2e:start
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Then you can run tests on client side:</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> client
<span class="token function">npm</span> run <span class="token builtin class-name">test</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>I wanted to have a script that runs <code>npm run e2e:reset-db</code> everytime the client tests restart, but did not do it yet. You&#39;ll have to do it by hand.</p><p>Tests are run within the browser, was just simpler for me to setup, and it is accurate. There are a lot more to tests, I just did the rendering tests for now.</p><h2 id="documentation-generation" tabindex="-1"><a class="header-anchor" href="#documentation-generation" aria-hidden="true">#</a> Documentation generation</h2><p>I appologize for how messy is the docs for grid and server: vuepress is not meant to render markdown from <code>ts-doc</code>, maybe in the future someone will come up with a tool to generate better markdowns.</p>`,29);function u(m,f){const s=o("ExternalLinkIcon");return i(),r("div",null,[c,t("p",null,[e("Search algorithm is a bit messy, I want to make it better, see "),t("a",l,[e("my messy research on it"),d(s)]),e(". Ask me directly if you want to improve it and are strugling to understand my mess.")]),p])}const b=n(h,[["render",u],["__file","dev.html.vue"]]);export{b as default};
