import { DicoIndex, OccurenceMap } from "./types";
import { readFile, readdir } from "fs/promises";
import { resolve } from "../utils";
/**
 * Dico is a sigleton class that contains the dictionnary
 * It is used to search for words in the grid
 */
export class Dico {
  /**
   * The list of words in the dictionnary
   */
  public words: string[] = [];
  /**
   * The map of words in the dictionnary
   */
  public wordsMap: Map<string, number> = new Map();
  /**
   * The promise that will resolve when the dictionnary is loaded
   */
  private loadingPromise: Promise<void>;
  /**
   * The occurences of the words in the dictionnary
   * The first element is for 2 letters lemmes
   * The second element is for 3 letters lemmes
   */
  public occurencies: OccurenceMap[];
  constructor() {
    this.words = [];
    this.wordsMap = new Map();
    this.occurencies = [{}, {}];
    this.loadingPromise = this.loadDictionary();
  }

  /**
   * For each letter of a word, count the occurences of the 2 or 3 letters lemmes
   * and add it to the occurences map
   * @param word  word to count occurences of
   * @param length length of the lemmes to count occurences of
   * @param index index of the word in the dictionnary
   * @param occs occurences map to add the occurences to
   * @returns The occurence map of the words
   */
  countOccurences({
    word,
    index,
    occs,
    length,
  }: {
    word: string;
    index: DicoIndex;
    occs: OccurenceMap;
    length: 2 | 3;
  }): void {
    for (
      let letterIndex = 0;
      letterIndex < word.length - length + 1;
      letterIndex++
    ) {
      const subWord = word.slice(letterIndex, letterIndex + length);
      if (!occs[subWord]) {
        occs[subWord] = {};
      }
      if (!occs[subWord][letterIndex]) {
        occs[subWord][letterIndex] = new Set();
      }
      occs[subWord][letterIndex].add(index);
    }
  }
  /**
   * Remove the occurences of a word from the occurences map
   * @param occsToRemove The occurenceMap generated by the word to remove
   * @param targetOccs The occurenceMap to cleanup
   * @param dicoIndex The index of the word to remove in the dictionnary
   */
  removeOccurence(
    occsToRemove: OccurenceMap,
    targetOccs: OccurenceMap,
    dicoIndex: DicoIndex
  ) {
    Object.entries(occsToRemove).forEach(([subWord, occByIndex]) => {
      Object.keys(occByIndex).forEach((letterIndex) => {
        const set = targetOccs[subWord][+letterIndex];
        set.delete(dicoIndex);
        if (set.size === 0) {
          delete targetOccs[subWord][+letterIndex];
        }
      });
      if (!Object.keys(targetOccs[subWord]).length) {
        delete targetOccs[subWord];
      }
    });
  }
  /**
   * Load the dictionnary from the files in the dictionnary folder
   * And in the user's dictionary
   * @returns The promise that will resolve when the dictionnary is loaded
   */
  loadDictionary() {
    if (this.loadingPromise) return this.loadingPromise;
    this.loadingPromise = readdir(resolve(APP_CROSSWORDS_DICO_PATH))
      .then((files) =>
        Promise.all(
          files.map((filePath) =>
            readFile(resolve(APP_CROSSWORDS_DICO_PATH, filePath), "utf8")
          )
        )
      )
      .then((responses) => {
        responses.forEach((response) => {
          this.addWordsToDictionnary(response as any as string);
        });
      });
    return this.loadingPromise;
  }
  /**
   * Add a word or a list of words to the dictionnary
   * @param data The word or the list of words to add
   */
  addWordsToDictionnary(data: string | string[]) {
    const { wordsMap } = this;
    let rawWords: string[] = [];
    if (typeof data === "string") {
      rawWords = data.split(/,|\n/);
    } else {
      rawWords = data;
    }
    rawWords
      .map((w) =>
        w
          .trim()
          .normalize("NFD")
          .replace(/[\u0300-\u036f]/g, "")
          .toUpperCase()
      )
      // .sort((a, b) => Math.abs(b.length - 10) - Math.abs(a.length - 10))
      .forEach((word) => {
        if (wordsMap.has(word)) return;
        const dicoIndex = this.words.length;
        wordsMap.set(word, dicoIndex);
        this.words.push(word);
        this.countOccurences({
          word,
          index: dicoIndex,
          length: 2,
          occs: this.occurencies[0],
        });
        this.countOccurences({
          word,
          index: dicoIndex,
          length: 3,
          occs: this.occurencies[1],
        });
      });
  }
  /**
   * Remove a word or a list of words from the dictionnary
   * Do not remove it from the array of words, just unreference it
   * from the occurence map and from the wordsMap
   * @param data The word or the list of words to remove
   */
  removeWordsFromDictionary(data: string | string[]) {
    return this.loadDictionary().then(() => {
      const { wordsMap } = this;
      let rawWords: string[] = [];
      if (typeof data === "string") {
        rawWords = data.split(/,|\n/);
      } else {
        rawWords = data;
      }
      rawWords
        .map((w) =>
          w
            .trim()
            .normalize("NFD")
            .replace(/[\u0300-\u036f]/g, "")
            .toUpperCase()
        )
        .forEach((word) => {
          const dicoIndex = wordsMap.get(word);
          if (!dicoIndex) return;
          // do not remove it from the array of words,
          // it would be unneficcient to reassign all the indexes.
          // Just unference it from the occurence map and from the wordsMap
          const occs2: OccurenceMap = {};
          const occs3: OccurenceMap = {};
          // count occurences of the word to remove
          // and then use it to cleanup
          this.countOccurences({
            word,
            index: dicoIndex,
            length: 2,
            occs: occs2,
          });
          this.countOccurences({
            word,
            index: dicoIndex,
            length: 3,
            occs: occs3,
          });
          this.removeOccurence(occs2, this.occurencies[0], dicoIndex);
          this.removeOccurence(occs3, this.occurencies[1], dicoIndex);
          wordsMap.delete(word);
        });
    });
  }
  /**
   * Get the list of words in the dictionnary
   * @returns All the words in the dictionnary
   */
  getWords() {
    return this.loadDictionary().then(() => this.words);
  }
  /**
   * If you know that the dictionnary is already loaded
   * @returns All the words in the dictionnary
   */
  getWordsSync() {
    return this.words;
  }
}

const dico = new Dico();
export default dico;
